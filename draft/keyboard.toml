[keyboard]
name = "draft keyboard"
product_name = "draft kbd"
vendor_id = 0x4c4b
product_id = 0x4643
manufacturer = "tib"
chip = "nrf52840"
# serial_number = "vial:f64c2b3c:000001"
#board = "nice!nano_v2"
# USB is enabled by default for most chips
# Set to false if you don't want USB
#usb_enable = true

[layout]
rows = 4
cols = 12
layers = 10
keymap = [
    #0 default: Hunglish layer
    [
        ["No", "No", "Y", "K", "R", "B",                                        "F", "C", "O", "U", "No", "No"],
        ["LCtrl",  "G", "MT(S, LAlt)", "MT(T,LShift)", "MT(L, LCtrl)", "V",     "J", "MT(N, RCtrl)", "MT(A, RShift)", "MT(E, LAlt)", "Semicolon", "Insert"],
        ["LShift", "MT(M, LGui)", "P", "W", "H", "Q",                           "X", "Z", "Dot", "Comma", "MT(I, RGui)", "Quote"],
        ["LAlt", "D", "LT(4, Escape)", "LT(2, Space)", "LT(5, Tab)", "OSL(6)",  "No", "LT(5, Enter)", "LT(2, Backspace)", "LT(4, Delete)", "Slash", "LGui"]
    ],
    
    #1 Hun mods of default
    [
        ["No", "No", "_", "_", "_", "_",                    "_", "_", "_", "_", "No", "No"],
        ["Minus", "_", "_", "_", "_", "_",                  "_", "_", "_", "_", "_", "Kc0"],
        ["LeftBracket", "_", "_", "_", "_", "_",            "_", "_", "_", "_", "_", "Quote"],
        ["Equal", "_", "_", "LT(3, Space)", "_", "OSL(7)",  "No", "_", "LT(3,Backspace)", "_", "_", "Grave"]
    ],

    #2 Numpad + Sym
    [
        ["No", "No", "Kc7", "Kc8", "Kc9", "KpMinus",                                   "WM(Grave, LShift)", "WM(Kc7, LShift)", "WM(LeftBracket, LShift)", "WM(RightBracket, LShift)", "No", "No"],
        ["KpSlash", "KpAsterisk", "Kc4", "Kc5", "Kc6", "KpPlus",                       "WM(Kc1, LShift)", "WM(Backslash, LShift)", "WM(Kc9, LShift)", "WM(Kc0, LShift)", "WM(Kc2, LShift)", "WM(Kc4, LShift)"],
        ["WM(Semicolon, LShift)", "Kp0", "Kc1", "KC2", "Kc3", "Grave",                 "WM(Slash, LShift)", "WM(Kc6, LShift)", "LeftBracket", "RightBracket", "WM(Quote, LShift)", "Quote"],
        ["WM(Kc5, LShift)", "KpDot", "_", "Equal", "WM(Minus, LShift)", "_",           "No", "WM(Comma, LShift)", "Equal", "WM(Dot, LShift)", "WM(Kc3, LShift)", "Backslash"]
    ],

    #3 Hun mods of Numpad + Sym
    [
        ["No", "No", "Kc7", "Kc8", "Kc9", "KpMinus",                                          "WM(Kc1, RAlt)", "WM(C, RAlt)", "WM(B, RAlt)", "WM(N, RAlt)", "No", "No"],
        ["KpSlash", "KpAsterisk", "Kc4", "Kc5", "Kc6", "KpPlus",                              "WM(Kc4, LShift)", "WM(W, RAlt)", "WM(Kc8, LShift)", "WM(Kc9, LShift)", "WM(V, RAlt)", "WM(Semicolon, RAlt)"],
        ["WM(Dot, LShift)", "Kp0", "Kc1", "KC2", "Kc3", "WM(Kc7, RAlt)",                      "WM(Comma, LShift)", "WM(Kc3, RAlt)", "WM(F, RAlt)", "WM(G, RAlt)", "WM(Kc2, LShift)", "WM(Kc1,LShift)"],
        ["WM(Kc5, LShift)", "KpDot", "_", "WM(Kc7, RShift)", "WM(Slash, RShift)", "_",        "No", "WM(NonusBackslash, RAlt)", "WM(Kc7, LShift)", "WM(Z, RAlt)", "WM(X, RAlt)", "WM(Q, RAlt)"]
    ],

    #4 Fn + Media
    [
        ["No", "No", "F7", "F8", "F9", "F10",                  "AudioVolUp", "MediaPrevTrack", "MediaPlayPause", "MediaStop", "No", "No"],
        ["LCtrl", "Pause", "F4", "F5", "F6", "F11",            "AudioMute", "RCtrl", "RShift", "LAlt", "MediaNextTrack", "WwwForward"],
        ["LShift", "PrintScreen", "F1", "F2", "F3", "F12",     "AudioVolDown", "MyComputer", "BrightnessUp", "BrightnessDown", "RGui", "WwwBack"],
        ["LAlt", "CapsLock", "_", "_", "_", "_",               "No", "_", "_", "_", "Calculator", "LGui"]
    ],

    #5 Nav + Shortcuts
    [
        ["No", "No", "WM(F, LCtrl)", "WM(Z, LCtrl)", "WM(Y, LCtrl)", "WM(V, LCtrl)",          "WM(Insert, RShift)", "MouseWheelLeft", "MouseWheelUp", "MouseWheelDown", "No", "No"],
        ["LCtrl", "WM(H, LCtrl)", "LAlt", "LShift", "LCtrl", "WM(C, LCtrl)",                  "WM(Insert, RCtrl)", "Left", "UP", "Down", "MouseWheelRight", "WwwForward"],
        ["LShift", "LGui", "MouseDown", "MouseUp", "MouseRight", "WM(X, LCtrl)",              "WM(X, LCtrl)", "Home", "PageUp", "PageDown", "Right", "WwwBack"],
        ["LAlt", "MouseLeft", "_", "_", "_", "_",                                             "No", "_", "_", "_", "End", "LGui"]
    ],

    #6 Layer locker
    [
        ["No", "No", "_", "_", "_", "_",     "_", "_", "_", "_", "No", "No"],
        ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],
        ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],        
        ["_", "_", "TG(4)", "TG(2)", "TG(5)", "TO(0)",   "No", "TG(5)", "TG(2)", "TG(4)", "_", "_"]
    ],

    #7 HunMod Layer locker
    [
        ["No", "No", "_", "_", "_", "_",     "_", "_", "_", "_", "No", "No"],
        ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],
        ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],        
        ["_", "_", "TG(4)", "TG(3)", "TG(5)", "TO(1)",   "No", "TG(5)", "TG(3)", "TG(4)", "_", "_"]
    ],

    #todo hun numpad + sym
    #todo fork on layer states?

    # #5 Mouse
    # [
    #     ["_", "_", "_", "_", "_", "_",    "_", "_", "_", "_", "_", "_"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "MouseLeft", "MouseUp", "MouseDown", "_", "_"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "MouseWheelLeft", "MouseWheelUp", "MouseWheelDown", "MouseRight", "_"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "MouseBtn3", "MouseBtn1", "MouseBtn2", "MouseWheelRight", "_"]
    # ]

    # #0 QWERTY like layer
    # [
    #     ["__", "__", "W", "E", "R", "T",                                   "Y", "U", "I", "O", "__", "__"],
    #     ["Escape", "Q", "MT(S,LAlt)", "MT(D,LShift)", "MT(F,LCtrl)", "G",  "H", "MT(J,RCtrl)", "MT(K,RShift)", "MT(L,LAlt)", "P", "Backspace"],
    #     ["LCtrl", "MT(A,LGui)", "X", "C", "V", "B",                        "N", "M", "Comma", "Dot", "MT(Semicolon,RGui)", "Enter"],
    #     ["LShift", "Z", "__", "LT(7,Escape)", "LT(5,Space)", "LT(6,Tab)",  "__", "LT(3,Enter)", "LT(2,Backspace)", "LT(4,Delete)", "Slash", "LAlt"]
    # ],

    # #1 homrow mods
    # [
    #     ["_", "_", "_", "_", "_", "_",                                   "_", "_", "_", "_", "_", "_"],
    #     ["_", "_", "MT(S,LAlt)", "MT(T,LShift)", "MT(R,LCtrl)", "_",     "_", "MT(N,RCtrl)", "MT(A,RShift)", "MT(E,LAlt)", "_", "_"],
    #     ["_", "MT(C,LGui)", "_", "_", "_", "_",                          "_", "_", "_", "_", "MT(I,RGui)", "_"],
    #     ["_", "_", "_", "_", "_", "_",                                   "_", "_", "_", "_", "_", "_"]
    # ],

    # #2 Numpad
    # [
    #     ["_", "_", "Kp7", "Kp8", "Kp9", "KpMinus",                       "_", "_", "_", "_", "_", "_"],
    #     ["WM(Comma, LShift)", "KpPlus", "Kp4", "Kp5", "Kp6", "Kp0",      "_", "_", "_", "_", "_", "_"], 
    #     ["Equal", "KpAsterisk", "Kp1", "Kp2", "Kp3", "KpDot",            "_", "_", "_", "_", "_", "_"],
    #     ["WM(Dot, LShift)", "KpSlash", "_", "_", "_", "_",               "_", "_", "_", "_", "_", "_"]
    # ],

    # #7 Media
    # [
    #     ["_", "_", "_", "_", "_", "_",    "WwwRefresh", "MediaPrevTrack", "MediaNextTrack", "Bootloader", "_", "_"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "MediaPlayPause", "MediaStop", "TG(1)", "BrightnessUp", "AudioVolUp"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "MyComputer", "Calculator", "WM(R,LGui)", "WM(L,LGui)", "AudioMute"],
    #     ["_", "_", "_", "_", "_", "_",    "_", "_", "_", "_", "BrightnessDown", "AudioVolDown"]
    # ]
]

[behavior.combo]
timeout = "150ms"
combos = [
  { actions = ["C", "O"], output = "F23" }, #ú
  { actions = ["O", "U"], output = "F24" }, #ű  
  { actions = ["F", "J"], output = "TG(1)" } #switch en/hun mode  
]

[behavior.fork]
forks = [
  # Shift + ' ' output '_' key
  { trigger = "Space", negative_output = "Space", positive_output = "WM(Minus, LShift)", match_any = "LShift|RShift" },  

  # 'F13' outputs '{', Shift + 'F13' output '[' key
  { trigger = "F13", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" }, 
  # 'F14' outputs '}', Shift + 'F14' output ']' key
  { trigger = "F14", negative_output = "WM(RightBracket, LShift)", positive_output = "RightBracket", match_any = "LShift|RShift" }, 
  # 'F15' outputs '(', Shift + 'F15' output '<' key
  { trigger = "F15", negative_output = "WM(Kc9, LShift)", positive_output = "WM(Comma, LShift)", match_any = "LShift|RShift" }, 
  # 'F16' outputs ')', Shift + 'F16' output '>' key
  { trigger = "F16", negative_output = "WM(Kc0, LShift)", positive_output = "WM(Dot, LShift)", match_any = "LShift|RShift" }, 
  # 'F17' outputs '/', Shift + 'F17' output '*' key
  { trigger = "F17", negative_output = "Slash", positive_output = "WM(Kc8, LShift)", match_any = "LShift|RShift" }, 
  # 'F18' outputs '"', Shift + 'F18' output ''' key
  { trigger = "F18", negative_output = "WM(Kc0, LShift)", positive_output = "WM(Dot, LShift)", match_any = "LShift|RShift" }, 

  # 'F19' outputs '.', Shift + 'F19' output '!' key
  { trigger = "F19", negative_output = "Dot", positive_output = "WM(Kc1, LShift)", match_any = "LShift|RShift" },
  # 'F20' outputs ';', Shift + 'F20' output ':' key
  { trigger = "F20", negative_output = "Semicolon", positive_output = "WM(Semicolon, LShift)", match_any = "LShift|RShift" },
  # 'F21' outputs ',', Shift + 'F21' output '?' key
  { trigger = "F21", negative_output = "Comma", positive_output = "WM(Slash, LShift)", match_any = "LShift|RShift" },
  # 'F22' outputs '=', Shift + 'F22' output '-' key
  { trigger = "F22", negative_output = "Equal", positive_output = "Minus", match_any = "LShift|RShift" },

  # 'F23' outputs 'ú', Shift + 'F23' output 'Ú' key
  { trigger = "F23", negative_output = "RightBracket", positive_output = "WM(RightBracket, LShift)", match_any = "LShift|RShift" }, #|CapsLock?
  # 'F24' outputs 'ű', Shift + 'F24' output 'Ű' key
  { trigger = "F24", negative_output = "Backslash", positive_output = "WM(Backslash, LShift)", match_any = "LShift|RShift" } #|CapsLock?

#   # left bracket outputs by default '{', with shifts pressed outputs '['  
#   { trigger = "LeftBracket", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" },

#   # flip the effect of shift on 'x'/'X'
#   { trigger = "X", negative_output = "WM(X, LShift)", positive_output = "X", match_any = "LShift|RShift" },

#   # F24 usually outputs 'a', except when Left Shift or Ctrl pressed, in that case triggers a macro 
#   { trigger = "F24", negative_output = "A", positive_output = "Macro1", match_any = "LShift|LCtrl" },

#   # swap Z and Y keys if MouseBtn1 is pressed (on the keyboard)  
#   { trigger = "Y", negative_output = "Y", positive_output = "Z", match_any = "CapsLock" },
#   { trigger = "Z", negative_output = "Z", positive_output = "Y", match_any = "CapsLock" },

#   # Shift + Backspace output Delete key (inside a layer tap/hold)
#   { trigger = "LT(2,Backspace)", negative_output = "LT(2,Backspace)", positive_output = "LT(2,Delete)", match_any = "LShift|RShift" },

#   # Ctrl + play/pause will send next track. MediaPlayPause -> MediaNextTrack
#   # Ctrl + Shift + play/pause will send previous track. MediaPlayPause -> MediaPrevTrack
#   # Alt + play/pause will send volume up. MediaPlayPause -> AudioVolUp
#   # Alt + Shift + play/pause will send volume down. MediaPlayPause -> AudioVolDown
#   # Ctrl + Alt + play/pause will send brightness up. MediaPlayPause -> BrightnessUp
#   # Ctrl + Alt + Shift + play/pause will send brightness down. MediaPlayPause -> BrightnessDown
#   # ( Note that the trigger and immediate trigger keys of the fork chain could be 'virtual keys', 
#   #   which will never output, like F23 but here multiple overrides demonstrate.)
#   { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "MediaNextTrack", match_any = "LCtrl|RCtrl", bindable = true },
#   { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "BrightnessUp", match_any = "LAlt|RAlt", bindable = true },
#   { trigger = "BrightnessUp", negative_output = "BrightnessUp", positive_output = "BrightnessDown", match_any = "LShift|RShift", bindable = false },
#   { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "MediaPrevTrack", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false},
#   { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "AudioVolUp", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
#   { trigger = "AudioVolUp", negative_output = "AudioVolUp", positive_output = "AudioVolDown", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false } 

#   { trigger = "P", negative_output = "P", positive_output = "F", match_any = "LCtrl|RCtrl", bindable = true },
#   { trigger = "F", negative_output = "F", positive_output = "B", match_any = "LAlt|RAlt", bindable = true },
#   { trigger = "B", negative_output = "B", positive_output = "D", match_any = "LShift|RShift", bindable = false },
#   { trigger = "F", negative_output = "F", positive_output = "R", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false},
#   { trigger = "P", negative_output = "P", positive_output = "V", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
#   { trigger = "V", negative_output = "V", positive_output = "W", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false } 
]

[storage]
enabled = true
# clear_storage = true
# Storage feature is enabled by default
# Start address of local storage, MUST BE start of a sector.
# If start_addr is set to 0(this is the default value), the last `num_sectors` sectors will be used.
# start_addr = 0x00000000
# How many sectors are used for storage, the default value is 2
# num_sectors = 2

[ble]
enabled = true
# nRF52840's saadc pin for reading battery level, you can use a pin number or "vddh"
#battery_adc_pin = "vddh"
# The voltage divider setting for saadc. 
# For example, nice!nano have 806 + 2M resistors, the saadc measures voltage on 2M resistor, so the two values should be set to 2000 and 2806
#adc_divider_measured = 2000
#adc_divider_total = 2806
# Pin that reads battery's charging state, `low-active` means the battery is charging when `charge_state.pin` is low
#charge_state = { pin = "PIN_1", low_active = true }
# Output LED pin that blinks when the battery is low
#charge_led= { pin = "PIN_2", low_active = true }

# [behavior.one_shot]
# timeout = "2s"

[behavior]
tap_hold = { enable_hrm = true, prior_idle_time = "120ms", hold_timeout = "300ms", post_wait_time = "50ms"}
#enable_hrm = true

# tri_layer = { upper = 1, lower = 2, adjust = 3 }
# one_shot = { timeout = "1s" }
# # Enable HRM 
# tap_hold = { enable_hrm = true, prior_idle_time = "120ms", hold_timeout = "250ms", post_wait_time = "50ms"}
# # Disable HRM, you can safely ignore any fields if you don't want to change them
# tap_hold = { enable_hrm = false, hold_timeout = "200ms" }
# [behavior.one_shot]
# timeout = "5s"

[light]
capslock = { pin = "P1_00", low_active = true }
scrolllock = { pin = "P0_22", low_active = true }
numslock = { pin = "P0_24", low_active = true }

# Dependency config
# [dependency]
# Whether to enable defmt, set to false for reducing binary size 
# defmt_log = true

[split]
connection = "ble" # "serial"

[split.central]
rows = 4 #5
cols = 6
row_offset = 0
col_offset = 6
ble_addr = [0x18, 0xe2, 0x21, 0x80, 0xc0, 0xc7]
[split.central.matrix]
matrix_type = "normal"
row2col = true
output_pins = ["P0_29", "P0_02", "P1_15", "P1_13"]
input_pins = ["P1_11", "P0_10", "P0_09", "P1_06", "P1_04", "P0_11"]

[[split.peripheral]]
rows = 4 #5
cols = 6
row_offset = 0
col_offset = 0
ble_addr = [0x7e, 0xfe, 0x73, 0x9e, 0x66, 0xe3]
[split.peripheral.matrix]
matrix_type = "normal"
row2col = true
output_pins = ["P0_29", "P0_02", "P1_15", "P1_13"]
input_pins = ["P0_11", "P1_04", "P1_06", "P0_09", "P0_10", "P1_11"]
