[keyboard]
name = "draft keyboard"
product_name = "draft kbd"
vendor_id = 0x4c4b
product_id = 0x4643
manufacturer = "tib"
chip = "nrf52840"
# serial_number = "vial:f64c2b3c:000001"
#board = "nice!nano_v2"
# USB is enabled by default for most chips
# Set to false if you don't want USB
#usb_enable = true

[rmk]
# Mouse key interval (ms) - controls mouse movement speed
mouse_key_interval = 20
# Mouse wheel interval (ms) - controls scrolling speed
mouse_wheel_interval = 80
# Maximum number of combos keyboard can store
combo_max_num = 32
# Maximum number of keys pressed simultaneously in a combo
combo_max_length = 4
# Maximum number of forks for conditional key actions
fork_max_num = 20
# Macro space size in bytes for storing sequences. The maximum number of Macros depends on the size of each sequence: All sequences combined need to fit into macro_space_size, the number of macro sequences doesn't matter.
macro_space_size = 256
# Default debounce time in ms
debounce_time = 20
# Event channel size
event_channel_size = 16
# Report channel size
report_channel_size = 16
# Vial channel size
vial_channel_size = 4
# Flash channel size
flash_channel_size = 4
# The number of the split peripherals
split_peripherals_num = 1
# The size of the split message channel
split_message_channel_size = 4
# The number of available BLE profiles
ble_profiles_num = 3

[aliases]
"~"="WM(Grave, LShift)"
"`"="Grave"
"!"="WM(Kc1, LShift)"
"@"="WM(Kc2, LShift)"
"#"="WM(Kc3, LShift)"
"$"="WM(Kc4, LShift)"
"%"="WM(Kc5, LShift)"
"^"="WM(Kc6, LShift)"
"&"="WM(Kc7, LShift)"
"*"="WM(Kc8, LShift)"
"("="WM(Kc9, LShift)"
")"="WM(Kc0, LShift)"
"-"="Minus"
"_"="WM(Minus, LShift)"
"="="Equal"
"+"="WM(Equal, LShift)"
"["="LeftBracket"
"{"="WM(LeftBracket, LShift)"
"]"="RightBracket"
"}"="WM(RightBracket, LShift)"
"\\"="Backslash"
"|"="WM(Backslash, LShift)"
";"="Semicolon"
":"="WM(Semicolon, LShift)"
"'"="WM(Quote, LShift)"
"\""="WM(Quote, LShift)"
","="Comma"
"<"="WM(Comma, LShift)"
"."="Dot"
">"="WM(Dot, LShift)"
"/"="Slash"
"?"="WM(Slash, LShift)"

"h~"="WM(Kc1, RAlt)"
"h`"="WM(Kc7, RAlt)"
"h!"="WM(Kc4, LShift)"
"h@"="WM(V, RAlt)"
"h#"="WM(X, RAlt)"
"h$"="WM(Semicolon, RAlt)"
"h%"="WM(Kc5, LShift)"
"h^"="WM(Kc3, RAlt)"
"h&"="WM(C, RAlt)"
"h*"="WM(Slash, RAlt)"
"h("="WM(Kc8, LShift)"
"h)"="WM(Kc9, LShift)"
"h-"="Slash"
"h_"="WM(Slash, LShift)"
"h="="WM(Kc7, LShift)"
"h+"="WM(Kc3, LShift)"
"h["="WM(F, RAlt)"
"h{"="WM(B, RAlt)"
"h]"="WM(G, RAlt)"
"h}"="WM(N, RAlt)"
"h\\"="WM(Q, RAlt)"
"h|"="WM(W, RAlt)"
"h;"="WM(Comma, RAlt)"
"h:"="WM(Dot, LShift)"
"h'"="WM(Kc1, LShift)"
"h\""="WM(Kc2, LShift)"
"h,"="Comma"
"h<"="WM(NonusBackslash, RAlt)"
"h."="Dot"
"h>"="WM(Y, RAlt)"
"h/"="WM(Kc6, LShift)"
"h?"="WM(Comma, LShift)"

"í"="Grave"
"ö"="Kc0"
"ü"="Minus"
"ó"="Equal" 
"ő"="LeftBracket"
"ú"="RightBracket"
"ű"="Backslash"
"é"="Semicolon"
"á"="Quote"

cut="WM(X, LCtrl)"
copy="WM(C, LCtrl)"
paste="WM(V, LCtrl)"
paste_noformat="WM(V, LCtrl|LShift)"
find="WM(F, LCtrl)"
replace="WM(H, LCtrl)"
undo="WM(Z, LCtrl)"
redo="WM(Y, LCtrl)"

R="LT(nav, R)"
K="LT(nav, K)"
M="LT(nav, M)"
I="LT(sym, I)"
hI="LT(sym_hun, I)"
# S="MT(S, LAlt)"
# T="MT(T, LShift)"
# L="MT(L, LCtrl)"
# N="MT(N, RCtrl)"
# A="MT(A, RShift)"
# E="MT(E, LAlt)"

[layout]
rows = 4
cols = 12
layers = 11
matrix_map = """
(1, 0) (1, 1) (0, 2) (0, 3) (0, 4) (0, 5)              (0, 6) (0, 7) (0, 8) (0, 9) (1, 10) (1, 11)
(2, 0) (2, 1) (1, 2) (1, 3) (1, 4) (1, 5)              (1, 6) (1, 7) (1, 8) (1, 9) (2, 10) (2, 11)
(3, 0) (3, 1) (2, 2) (2, 3) (2, 4) (2, 5)              (2, 6) (2, 7) (2, 8) (2, 9) (3, 10) (3, 11)
                           (3, 2) (3, 3) (3, 4)  (3, 7) (3, 8) (3, 9)
(3, 5)
"""

# [[layer]]
# name = "default" #1 (COLEMAK-DH)
# keys ="""
# LCtrl   Q  W  F  P  B                  J  L  U  Y  ;  Insert
# LShift  A  R  S  T  G                  M  N  E  I  O @"
# LAlt    Z  X  C  D  V                  K  H @, @. @/  LGui
# LT(functions, Escape) LT(symbols, Space) LT(navigation, Tab)  LT(symbols, Enter) LT(navigation, Backspace) LT(functions, Delete) 
# OSL(locker)
# """

# [[layer]]
# name = "default" #1 (COLEMAK-mymod)
# keys ="""
# LCtrl   F  Y  D  G  V                  P  Z  U  J @;  Insert
# LShift  A  R  S  T  B                  H  N  E  I  O @"
# LAlt    W  C  M  K  Q                  X  L @/ @, @.  LGui
# LT(functions, Escape) LT(symbols, Space) LT(navigation, Tab)  LT(symbols, Enter) LT(navigation, Backspace) LT(functions, Delete) 
# OSL(locker)
# """

# [[layer]]
# name = "default" #0 (Hunglish)
# keys ="""
# LCtrl   G  Y  K  R  B                  F  C  O  U @; Insert
# LShift @m @s @t @l  V                  J @n @a @e @i Quote
# LAlt    P  D  W  H  Q                  X  Z @, @= @. LGui
# LT(functions, Escape) LT(symbols, Space) LT(navigation, Tab)  LT(symbols, Enter) LT(navigation, Backspace) LT(functions, Delete) 
# OSL(locker)
# """

[[layer]]
name = "eng"
keys ="""
LAlt    G  Y  M  R  B                  F  C  O  U @; RAlt
LShift @K  S  T  L  V                  J  N  A  E @I RShift
LCtrl   D  P  W  H  Q                  X  Z @, @= @. LGui
LT(media, Escape) LT(sym, Space) WM(Tab, LShift)   WM(Enter, RShift) LT(nav, Backspace) LT(num, Delete) 
OSL(lock)
"""

[[layer]]
name = "hun"
keys ="""
@ü      G  Y  M  R  B                  F  C  O  U @é  @ö
LShift @K  S  T  L  V                  J  N  A  E @hI RShift
LCtrl   D  P  W  H  Q                  X  Z @, @= @.  LGui
LT(media, Escape) LT(sym_hun, Space) WM(Tab, LShift)   WM(Enter, RShift) LT(nav, Backspace) LT(num, Delete) 
OSL(lock_hun)
"""

[[layer]]
name = "new"
keys ="""
LAlt    K  D  M  Z  B                  F  H  O  U  Q  RAlt
LShift @R  S  T  L  C                  J  N  A  E @I  RShift
LCtrl   P  Y  V  G  W                  X @, @; @= @.  LGui
LT(media, Escape) LT(sym, Space) WM(Tab, LShift)   WM(Enter, RShift) LT(nav, Backspace) LT(num, Delete) 
OSL(lock)
"""

[[layer]]
name = "qwerty"
keys ="""
LAlt    Q  W  E  R  T                  Y  U  I  O  P  RAlt
LShift  A  S  D  F  G                  H  J  K  L @;  RShift
LCtrl   Z  X  C  V  B                  N  M @, @. @/  LGui
LT(media, Escape) LT(sym, Space) WM(Tab, LShift)   WM(Enter, RShift) LT(nav, Backspace) LT(num, Delete) 
OSL(lock)
"""

[[layer]]
name = "sym" 
keys ="""
LAlt   @` @^ @& @| @~          @! @" @{ @} @/ RAlt
LShift @_ @< @= @> @\\         @- @' @( @) @* RShift
LCtrl  @$ @# @@ @% @*          @? @: @[ @] @+ LGui
                  _ _ _      _ _ _
_
"""

[[layer]]
name = "sym_hun" 
keys ="""
LAlt   @h` @h^ @h& @h| @h~     @h! @h" @h{ @h} @h/ RAlt
LShift @h_ @h< @h> @h= @h\\    @h- @h' @h( @h) @h* RShift
LCtrl  @h$ @h# @h@ @h% @h*     @h? @h: @h[ @h] @h+ LGui
                     _ _ _    _ _ _
_
"""

[[layer]]
name = "num" 
keys ="""
LAlt   PrintScreen  F7 F8 F9 F12    KpPlus  Kp7 Kp8 Kp9 KpSlash    RAlt
LShift Insert       F4 F5 F6 F11    KpMinus Kp4 Kp5 Kp6 KpAsterisk RShift
LCtrl  Pause        F1 F2 F3 F10    Kp0     Kp1 Kp2 Kp3 KpDot      LGui
                           _ _ _    _ _ _
_
"""

[[layer]]
name = "nav"
keys ="""
LAlt   @undo          @paste_noformat @paste         @copy           @cut           @cut       @copy @paste @paste_noformat @undo RAlt
LShift @redo          MouseBtn2       MouseBtn3      MouseBtn1       MouseBtn4      WwwForward Left  UP     Down            Right RShift
LCtrl  MouseLeft      MouseDown       MouseUp        MouseRight      MouseBtn5      WwwBack    Home  PageUp PageDown        End   LGui
                                                                      _ _ _         _ _ _
_
"""

[[layer]]
name = "media" #media, bluetooth, mouse scroll
keys ="""
LAlt   NumLock    F7 F8 F9 F12     AudioVolUp   MediaPrevTrack MediaPlayPause MediaStop      MediaNextTrack  RAlt
LShift CapsLock   F4 F5 F6 F11     AudioMute    MouseWheelLeft MouseWheelUp   MouseWheelDown MouseWheelRight RShift
LCtrl  ScrollLock F1 F2 F3 F10     AudioVolDown MyComputer     BrightnessUp   BrightnessDown Calculator      LGui                         
                         _ _ _     _ _ _
_
"""

[[layer]]
name = "lock"
keys ="""
TG(eng)     _ _ _ _ _          _ _ _ _ _ TG(new)
TG(hun)     _ _ _ _ _          _ _ _ _ _ _
TG(qwerty)  _ _ _ _ _          _ _ _ _ _ _        
TG(media) TG(sym) TG(nav)      TG(sym) TG(nav) TG(num)
TO(eng)
"""

[[layer]]
name = "lock_hun"
keys ="""
TG(eng)     _ _ _ _ _          _ _ _ _ _ TG(new)
TG(hun)     _ _ _ _ _          _ _ _ _ _ _
TG(qwerty)  _ _ _ _ _          _ _ _ _ _ _        
TG(media) TG(sym_hun) TG(nav)    TG(sym_hun) TG(nav) TG(num)
TO(hun)
"""

# [[layer]]
# name = "numbers" #2
# keys ="""
# KpSlash KpAsterisk Kc7 Kc8 Kc9 KpMinus   _ _ _ _ _ _
# @: Kp0 Kc4 Kc5 Kc6 KpPlus                _ RCtrl RShift LAlt RGui _
# Grave KpDot Kc1 Kc2 Kc3 @%               _ _ _ _ _ _
# Semicolon Space Equal                    _ _ _
# _
# """

# Mouse Nav + Shortcuts
# No No _ _ _ _            @cut @copy @paste WM(V, LCtrl|LShift) No No
# _ _ LAlt LShift LCtrl _  WwwForward MouseWheelLeft MouseWheelUp MouseWheelDown WM(Z, LCtrl) WM(Y, LCtrl)
# _ LGui _ _ _ _           WwwBack MouseLeft MouseUp MouseDown MouseWheelRight @find
# _ _ _ _ _ _              No MouseBtn2 MouseBtn1 MouseBtn3 MouseRight @replace

# #1 Hun mods of default
# [
#     ["No", "No", "_", "_", "_", "_",                    "_", "_", "_", "_", "No", "No"],
#     ["Minus", "_", "_", "_", "_", "_",                  "_", "_", "_", "_", "_", "Kc0"],
#     ["LeftBracket", "LT(3, M)", "_", "_", "_", "_",     "_", "_", "_", "_", "LT(3, I)", "Quote"],
#     ["Equal", "_", "_", "_", "_", "OSL(8)",             "No", "_", "LT(3,Backspace)", "_", "_", "Grave"]
# ],
# #3 Hun mods of Sym
# [
#     ["No", "No", "Kc7", "Kc8", "Kc9", "KpMinus",                                          "WM(Kc1, RAlt)", "WM(C, RAlt)", "WM(B, RAlt)", "WM(N, RAlt)", "No", "No"],
#     ["KpSlash", "KpAsterisk", "Kc4", "Kc5", "Kc6", "KpPlus",                              "WM(Kc4, LShift)", "WM(W, RAlt)", "WM(Kc8, LShift)", "WM(Kc9, LShift)", "WM(V, RAlt)", "WM(Semicolon, RAlt)"],
#     ["WM(Dot, LShift)", "Kp0", "Kc1", "Kc2", "Kc3", "WM(Kc7, RAlt)",                      "WM(Comma, LShift)", "WM(Kc3, RAlt)", "WM(F, RAlt)", "WM(G, RAlt)", "WM(Kc2, LShift)", "WM(Kc1,LShift)"],
#     ["WM(Kc5, LShift)", "KpDot", "_", "WM(Kc7, RShift)", "WM(Slash, RShift)", "_",        "No", "WM(NonusBackslash, RAlt)", "WM(Kc7, LShift)", "WM(Z, RAlt)", "WM(X, RAlt)", "WM(Q, RAlt)"]
# ],
# #9 HunMod Layer locker
# [
#     ["No", "No", "_", "_", "_", "_",     "_", "_", "_", "_", "No", "No"],
#     ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],
#     ["_", "_", "_", "_", "_", "_",       "_", "_", "_", "_", "_", "_"],        
#     ["_", "_", "TG(4)", "TG(3)", "TG(5)", "TO(1)",   "No", "TG(5)", "TG(3)", "TG(4)", "_", "_"]
# ],

#todo hun numpad + sym
#todo fork on layer states?

# #5 Mouse
# [
#     ["_", "_", "_", "_", "_", "_",    "_", "_", "_", "_", "_", "_"],
#     ["_", "_", "_", "_", "_", "_",    "_", "MouseLeft", "MouseUp", "MouseDown", "_", "_"],
#     ["_", "_", "_", "_", "_", "_",    "_", "MouseWheelLeft", "MouseWheelUp", "MouseWheelDown", "MouseRight", "_"],
#     ["_", "_", "_", "_", "_", "_",    "_", "MouseBtn3", "MouseBtn1", "MouseBtn2", "MouseWheelRight", "_"]
# ]

# #0 QWERTY like layer
# [
#     ["__", "__", "W", "E", "R", "T",                                   "Y", "U", "I", "O", "__", "__"],
#     ["Escape", "Q", "MT(S,LAlt)", "MT(D,LShift)", "MT(F,LCtrl)", "G",  "H", "MT(J,RCtrl)", "MT(K,RShift)", "MT(L,LAlt)", "P", "Backspace"],
#     ["LCtrl", "MT(A,LGui)", "X", "C", "V", "B",                        "N", "M", "Comma", "Dot", "MT(Semicolon,RGui)", "Enter"],
#     ["LShift", "Z", "__", "LT(7,Escape)", "LT(5,Space)", "LT(6,Tab)",  "__", "LT(3,Enter)", "LT(2,Backspace)", "LT(4,Delete)", "Slash", "LAlt"]
# ],

# #1 homrow mods
# [
#     ["_", "_", "_", "_", "_", "_",                                   "_", "_", "_", "_", "_", "_"],
#     ["_", "_", "MT(S,LAlt)", "MT(T,LShift)", "MT(R,LCtrl)", "_",     "_", "MT(N,RCtrl)", "MT(A,RShift)", "MT(E,LAlt)", "_", "_"],
#     ["_", "MT(C,LGui)", "_", "_", "_", "_",                          "_", "_", "_", "_", "MT(I,RGui)", "_"],
#     ["_", "_", "_", "_", "_", "_",                                   "_", "_", "_", "_", "_", "_"]
# ],

# #2 Numpad
# [
#     ["_", "_", "Kp7", "Kp8", "Kp9", "KpMinus",                       "_", "_", "_", "_", "_", "_"],
#     ["WM(Comma, LShift)", "KpPlus", "Kp4", "Kp5", "Kp6", "Kp0",      "_", "_", "_", "_", "_", "_"], 
#     ["Equal", "KpAsterisk", "Kp1", "Kp2", "Kp3", "KpDot",            "_", "_", "_", "_", "_", "_"],
#     ["WM(Dot, LShift)", "KpSlash", "_", "_", "_", "_",               "_", "_", "_", "_", "_", "_"]
# ],

# #7 Media
# [
#     ["_", "_", "_", "_", "_", "_",    "WwwRefresh", "MediaPrevTrack", "MediaNextTrack", "Bootloader", "_", "_"],
#     ["_", "_", "_", "_", "_", "_",    "_", "MediaPlayPause", "MediaStop", "TG(1)", "BrightnessUp", "AudioVolUp"],
#     ["_", "_", "_", "_", "_", "_",    "_", "MyComputer", "Calculator", "WM(R,LGui)", "WM(L,LGui)", "AudioMute"],
#     ["_", "_", "_", "_", "_", "_",    "_", "_", "_", "_", "BrightnessDown", "AudioVolDown"]
# ]

[behavior.combo]
timeout = "150ms"
combos = [
  { actions = ["F", "J"], output = "TG(1)" }, #switch en/hun mode  
  { actions = ["C", "O"], output = "[" }, #ő
  { actions = ["H", "O"], output = "[" }, #ő
  { actions = ["O", "U"], output = "\\" }, #ű  
  #{ actions = ["M", "K"], output = "`" }, #í
  { actions = ["M", "R"], output = "`" }, #í
  { actions = ["M", "Z"], output = "`" }, #í
  #{ actions = ["Y", "K"], output = "]" }, #ú
  { actions = ["Y", "M"], output = "]" }, #ú
  { actions = ["D", "M"], output = "]" }, #ú
]

[behavior.fork]
forks = [
  # Shift + ' ' output '_' key
  { trigger = "Space", negative_output = "Space", positive_output = "WM(Minus, LShift)", match_any = "LShift|RShift" },  

  # 'F13' outputs '{', Shift + 'F13' output '[' key
  { trigger = "F13", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" }, 
  # 'F14' outputs '}', Shift + 'F14' output ']' key
  { trigger = "F14", negative_output = "WM(RightBracket, LShift)", positive_output = "RightBracket", match_any = "LShift|RShift" }, 
  # 'F15' outputs '(', Shift + 'F15' output '<' key
  { trigger = "F15", negative_output = "WM(Kc9, LShift)", positive_output = "WM(Comma, LShift)", match_any = "LShift|RShift" }, 
  # 'F16' outputs ')', Shift + 'F16' output '>' key
  { trigger = "F16", negative_output = "WM(Kc0, LShift)", positive_output = "WM(Dot, LShift)", match_any = "LShift|RShift" }, 
  # 'F17' outputs '/', Shift + 'F17' output '*' key
  { trigger = "F17", negative_output = "Slash", positive_output = "WM(Kc8, LShift)", match_any = "LShift|RShift" }, 
  # 'F18' outputs '"', Shift + 'F18' output ''' key
  { trigger = "F18", negative_output = "WM(Kc0, LShift)", positive_output = "WM(Dot, LShift)", match_any = "LShift|RShift" }, 

  # 'F19' outputs '.', Shift + 'F19' output '!' key
  { trigger = "F19", negative_output = "Dot", positive_output = "WM(Kc1, LShift)", match_any = "LShift|RShift" },
  # 'F20' outputs ';', Shift + 'F20' output ':' key
  { trigger = "F20", negative_output = "Semicolon", positive_output = "WM(Semicolon, LShift)", match_any = "LShift|RShift" },
  # 'F21' outputs ',', Shift + 'F21' output '?' key
  { trigger = "F21", negative_output = "Comma", positive_output = "WM(Slash, LShift)", match_any = "LShift|RShift" },
  # 'F22' outputs '=', Shift + 'F22' output '-' key
  { trigger = "F22", negative_output = "Equal", positive_output = "Minus", match_any = "LShift|RShift" },

  # # 'F23' outputs 'ú', Shift + 'F23' output 'Ú' key
  # { trigger = "F23", negative_output = "RightBracket", positive_output = "WM(RightBracket, LShift)", match_any = "LShift|RShift" }, #|CapsLock?
  # # 'F24' outputs 'ű', Shift + 'F24' output 'Ű' key
  # { trigger = "F24", negative_output = "Backslash", positive_output = "WM(Backslash, LShift)", match_any = "LShift|RShift" } #|CapsLock?

#   # left bracket outputs by default '{', with shifts pressed outputs '['  
#   { trigger = "LeftBracket", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" },

#   # flip the effect of shift on 'x'/'X'
#   { trigger = "X", negative_output = "WM(X, LShift)", positive_output = "X", match_any = "LShift|RShift" },

#   # F24 usually outputs 'a', except when Left Shift or Ctrl pressed, in that case triggers a macro 
#   { trigger = "F24", negative_output = "A", positive_output = "Macro1", match_any = "LShift|LCtrl" },

#   # swap Z and Y keys if MouseBtn1 is pressed (on the keyboard)  
#   { trigger = "Y", negative_output = "Y", positive_output = "Z", match_any = "CapsLock" },
#   { trigger = "Z", negative_output = "Z", positive_output = "Y", match_any = "CapsLock" },

#   # Shift + Backspace output Delete key (inside a layer tap/hold)
#   { trigger = "LT(2,Backspace)", negative_output = "LT(2,Backspace)", positive_output = "LT(2,Delete)", match_any = "LShift|RShift" },

#   # Ctrl + play/pause will send next track. MediaPlayPause -> MediaNextTrack
#   # Ctrl + Shift + play/pause will send previous track. MediaPlayPause -> MediaPrevTrack
#   # Alt + play/pause will send volume up. MediaPlayPause -> AudioVolUp
#   # Alt + Shift + play/pause will send volume down. MediaPlayPause -> AudioVolDown
#   # Ctrl + Alt + play/pause will send brightness up. MediaPlayPause -> BrightnessUp
#   # Ctrl + Alt + Shift + play/pause will send brightness down. MediaPlayPause -> BrightnessDown
#   # ( Note that the trigger and immediate trigger keys of the fork chain could be 'virtual keys', 
#   #   which will never output, like F23 but here multiple overrides demonstrate.)
#   { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "MediaNextTrack", match_any = "LCtrl|RCtrl", bindable = true },
#   { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "BrightnessUp", match_any = "LAlt|RAlt", bindable = true },
#   { trigger = "BrightnessUp", negative_output = "BrightnessUp", positive_output = "BrightnessDown", match_any = "LShift|RShift", bindable = false },
#   { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "MediaPrevTrack", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false},
#   { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "AudioVolUp", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
#   { trigger = "AudioVolUp", negative_output = "AudioVolUp", positive_output = "AudioVolDown", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false } 

#   { trigger = "P", negative_output = "P", positive_output = "F", match_any = "LCtrl|RCtrl", bindable = true },
#   { trigger = "F", negative_output = "F", positive_output = "B", match_any = "LAlt|RAlt", bindable = true },
#   { trigger = "B", negative_output = "B", positive_output = "D", match_any = "LShift|RShift", bindable = false },
#   { trigger = "F", negative_output = "F", positive_output = "R", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false},
#   { trigger = "P", negative_output = "P", positive_output = "V", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
#   { trigger = "V", negative_output = "V", positive_output = "W", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false } 
]

[storage]
enabled = true
# clear_storage = true
# Storage feature is enabled by default
# Start address of local storage, MUST BE start of a sector.
# If start_addr is set to 0(this is the default value), the last `num_sectors` sectors will be used.
# start_addr = 0x00000000
# How many sectors are used for storage, the default value is 2
# num_sectors = 2

[ble]
enabled = true
# nRF52840's saadc pin for reading battery level, you can use a pin number or "vddh"
#battery_adc_pin = "vddh"
# The voltage divider setting for saadc. 
# For example, nice!nano have 806 + 2M resistors, the saadc measures voltage on 2M resistor, so the two values should be set to 2000 and 2806
#adc_divider_measured = 2000
#adc_divider_total = 2806
# Pin that reads battery's charging state, `low-active` means the battery is charging when `charge_state.pin` is low
#charge_state = { pin = "PIN_1", low_active = true }
# Output LED pin that blinks when the battery is low
#charge_led= { pin = "PIN_2", low_active = true }

# [behavior.one_shot]
# timeout = "2s"

[behavior]
tap_hold = { enable_hrm = true, prior_idle_time = "120ms", hold_timeout = "250ms", post_wait_time = "50ms"}
#enable_hrm = true

# tri_layer = { upper = 1, lower = 2, adjust = 3 }
# one_shot = { timeout = "1s" }
# # Enable HRM 
# tap_hold = { enable_hrm = true, prior_idle_time = "120ms", hold_timeout = "250ms", post_wait_time = "50ms"}
# # Disable HRM, you can safely ignore any fields if you don't want to change them
# tap_hold = { enable_hrm = false, hold_timeout = "200ms" }
# [behavior.one_shot]
# timeout = "5s"

[light]
capslock = { pin = "P1_00", low_active = true }
scrolllock = { pin = "P0_22", low_active = true }
numslock = { pin = "P0_24", low_active = true }

# Dependency config
# [dependency]
# Whether to enable defmt, set to false for reducing binary size 
# defmt_log = true

[split]
connection = "ble" # "serial"

[split.central]
rows = 4 #5
cols = 6
row_offset = 0
col_offset = 0
ble_addr = [0x18, 0xe2, 0x21, 0x80, 0xc0, 0xc7]

[split.central.matrix]
matrix_type = "normal"
row2col = true
output_pins = ["P0_29", "P0_02", "P1_15", "P1_13"]
input_pins = ["P0_11", "P1_04", "P1_06", "P0_09", "P0_10", "P1_11"]

[[split.peripheral]]
rows = 4 #5
cols = 6
row_offset = 0
col_offset = 6
ble_addr = [0x7e, 0xfe, 0x73, 0x9e, 0x66, 0xe3]

[split.peripheral.matrix]
matrix_type = "normal"
row2col = true
output_pins = ["P0_29", "P0_02", "P1_15", "P1_13"]
input_pins = ["P1_11", "P0_10", "P0_09", "P1_06", "P1_04", "P0_11"]

